# Attack Lab
### 收获
熟悉了代码注入和ROP两种利用程序堆栈的攻击方式，了解了程序堆栈中可能存在的安全漏洞。\
更深入地认识了x86的堆栈机制。\
### 总结
本实验主要关于程序的缓冲区及相关的安全知识。\
可以了解攻击者利用缓冲区安全漏洞的方式，更好地理解如何编写更安全的程序。\
了解x86-64的堆栈和参数传递机制。\
更深入地理解x86-64的编码。\
熟悉GDB等工具。
### 未解之谜
Level2中，想直接把第二个返回地址放在第一个返回地址的上面8字节，不用push指令，但是不行。\
Level3中，想通过注入代码修改栈指针，从而避免对栈空间的覆写，但是不行。猜测是程序不允许修改栈指针。
### 实验要求
本实验涉及对含有缺陷的两个程序的五个安全漏洞进行攻击。\
两个程序分别使用code-injection attacks和return-oriented-programming attacks。
### Level 1
不需要注入新代码。用攻击字符串来把程序重定向到一个现存的代码位置。\
任务是让CTARGET在getbuf函数执行返回语句时执行touch1函数的代码。而不是回到调用它的test函数。\
官方提示：一切需要用到的信息都可以通过研究CTARGET的反汇编代码来得到。思路是获取touch1函数起始地址的字节表示，以便ret指令可以把控制转交给touch1。\
在x86中，call指令会把返回地址压入栈中。只要把这部分信息覆盖为想要的信息即可。\
touch1函数的起始地址是0x4017c0。\

```C++
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp //扩展了40字节栈空间。字符串存在栈中，说明只要填40字节的字符串，此后再往里填充需要的地址即可。
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
```
所以可得出level1的答案就是，先填40字节的任意数据，再填充地址0x4017c0，注意小端法的字节顺序，应该填入c0 17 40 00。需要使用hex2raw程序来把填入的十六进制数转为字符串。\
### Level 2
需要注入一小部分代码作为攻击字符串的一部分。\
任务是让CTARGET在getbuf函数执行返回语句时执行touch2函数的代码，而不是回到test函数。touch2函数需要一个参数，这个参数必须是cookie值。\
官方提示：需要注入的代码的地址；函数的第一个参数通过寄存器rdi传递；注入的代码需要把寄存器设为cookie，然后用ret指令把控制转交给touch2；不要尝试注入jmp或call指令。\
touch2的地址是0x004017ec。\
由上，注入的代码就是三条，
movl $0x59b997fa, %edi
pushq 0x004017ec
ret
\
在前40字节的最开始的部分包括这些代码的十六进制编码。40字节后的8字节需要注入位置的地址，再向上的8字节需要touch2的地址。\
字节码是 bf fa 97 b9 59 68 ec 17 40 00 c3 。占了前11个字节。\
用gdb可知test中的返回地址被放在0x5561dca0。所以我们的注入代码的地址就会在0x5561dc78。\
由此易得答案。\

### Level 3
需要代码注入，传递一个字符串作为参数。\
任务是让CTARGET在getbuf函数执行返回语句时执行touch3函数的代码，而不是回到test函数。touch3以一个字符串作为参数，我们要让touch3收到一个cookie的字符串表示的参数。\
官方提示：需要在攻击字符串中包含cookie的字符串表示；这个字符串包含8个十六进制位，没有前导0x；字符串在C中是一系列的字节，最后是\0；注入代码应当把%rdi设为字符串的地址；函数hexmatch和strncmp调用时，它们把数据放到栈上，覆写掌管由getbuf使用的缓冲区的内存部分。\
需要担心被覆盖的，就是cookie的字符串表示。得另外找个安全的地方放置。但我想到，栈会被覆盖是因为getbuf函数最后把栈指针加了0x28，释放了它的栈空间。那我在注入代码中再执行一次栈指针减去0x28，不就恢复了对栈空间的使用吗，从而避免被覆盖。当然，试了以后果然不行，虽然我理论分析感觉没问题。但是程序好像不允许我修改栈指针。\
只能用另一种解法，就是把字符串放在test的栈里。那就再往上填。\
cookie值是0x59b997fa，对应的字符串表示是（十六进制）35 39 62 39 39 37 66 61 \
touch3的地址是0x004018fa。\
先放字符串表示，地址会在0x5561dc78。占8个字节，所以注入代码地址会在0x5561dc80。\
注入的代码：
movl $0x5561dca8, %edi
pushq $0x004018fa
ret\
在注入代码之后，补足40个字节，然后放注入代码地址80 dc 61 55.\
注入代码的字节码是bf 78 dc 61 55 48 83 ec 28 ff 34 25 fa 18 40 00 c3，有17个字节，加上cookie的8字节，有25字节，所以补15字节。可得答案。\

### Phase 4
最后两个phase属于part 2。需要攻击RTARGET程序。\
攻击RTARGET要比CTARGET更难，因为它使用了两个技术阻止代码注入：随机化技术，使程序运行时堆栈配置不同，所以无法确定注入代码的位置；把栈的部分标记为不可执行，所以注入在栈中的代码无法被执行。\
但是，我们可以通过让程序执行现存的代码，而不是新代码，来攻击程序。最普遍的这种攻击形式就叫做ROP（面向返回编程）。ROP的策略是，识别在现存程序内的字节序列，这个字节序列包括一或多条指令，并且最后是指令ret。这样的一个片段被叫作gadget。\
我们在part 2中，需要在gadget farm中找到这样的gadget，用它们来进行攻击。farm由start_farm和end_farm标明。不要尝试用程序的其他部分构造gadget。\
Phase 4要重复phase 2的攻击，但是是通过使用gadget的方式攻击RTARGET。可能使用到movq popq ret nop指令。\
官方建议：所有的gadget都可以在start_farm到mid_farm间找到；这次攻击只需要两个gadget；当一个gadget使用popq指令时，它会从栈中弹出数据，因此，攻击字符串需要包含gadget的地址和数据。\
显然，要构造的gadget，是利用pop，取出我们放在栈里的cookie；如果不能直接pop到edi里，就需要再构造一个mov的gadget。\
攻击字符串先填满40字节，然后8字节放第一个gadget的地址，然后8字节放cookie，然后8字节放第二个gadget的地址（如果有），然后8字节放touch2的地址0x004017ec。\
果然找不到直接pop到rdi的5f。\
能找到58 5c。58 90 c3可以和48 89 c7 c3配合。
前者地址是0x4019cc，后者地址是0x4019a2。\

### Phase 5
Phase 5要通过使用gadget的方式对RTARGET重复phase 3的攻击。\
官方建议：注意movl指令会清零寄存器的高位4字节；可能用到8个gadget。\
思路是，cookie串肯定要放到栈的最上面，以防被覆盖。这个地址可以用rsp+一个偏移量的方式。这个偏移量放在栈里利用pop得到。farm里提供了一个实现rax=rdi+rsi的gadget，利用它来获得最终地址。串的地址放入rdi后，就可以调用touch3了。\
攻击字符串，先填满40字节，然后放第一个gadget地址401a06；然后放第二个gadget地址4019a2，然后放第三个gadget地址4019ab，然后放偏移量（计算出来是9*8=72，也就是0x48），然后放第四个gadget地址，一直放到第8个gadget地址，然后放touch3地址004018fa。然后放cookie字符串35 39 62 39 39 37 66 61。\
第一个gadget，内容是获取rsp。可以找到48 89 e0 c3，地址是401a06。作用是把rsp给了rax。
第二个gadget，内容是把rax给rdi，可以找到48 89 c7 c3，地址是4019a2。作用是rdi=rax。
第三个gadget，内容是获取偏移量，这个偏移量待定。58 90 c3，地址是4019ab。作用是pop rax。
第四个gadget。89 c2 90 c3，地址是4019dd，作用是edx=eax。
第五个gadget，89 d1 08 db c3，地址是401a69，作用是ecx=edx。
第六个gadget，89 ce 90 90 c3，地址是401a13，作用是esi=ecx。
第七个gadget，地址4019d6，作用是rax=rdi+rsi。
第八个，地址4019a2，rdi=rax。

完结撒花。\




