# Shell Lab
### 收获
熟悉了进程的控制和针对信号的控制，熟悉了许多相关函数；\
了解了shell的实现原理；\
进程控制和信号控制比较复杂，对于要实现安全、正确的处理难度较大，需要深刻理解其机制，并且谨慎编写代码；\
对于代码量较大的编程内容，各部分之间的关联比较复杂，如果思路有偏差，很可能产生各种难以发现和纠正的错误，尽量在一开始就保证实现思路是正确的。本实验并不涉及什么有难度的算法和数据结构，但信号的处理、进程的处理如果不当，往往会产生一些令人费解的问题。\
本实验涉及许多处理信号和进程的函数，这些函数以前是很少接触的，使用时需要仔细阅读文档，否则如果使用不当，会产生难以发现和纠正的错误；\
这种实验比较接近工程，和算法竞赛的编程不同，这里注重实际使用，而不是只考虑格式一定正确的输入情况，所以需要小心地检查所有函数的返回值，并且谨慎地考虑所有可能的输入情况；\
竞争：几个过程之间争夺执行，程序的结果和它们执行的顺序有关。这肯定是不行的。\
另外，信号是不排队的，程序运行时如果有多个相同的信号到达，一个信号会先被处理，只有一个信号会等待，其他未处理的信号会被丢弃。
### 总结
本实验旨在让我们熟悉进程控制和信号的概念。我们需要写一个简单的支持作业控制的Unix shell程序。
### 实验前置知识
Shell是一个交互的命令行解释器，代表用户运行程序。一个shell会重复打印提示符，等待一个命令行，执行命令行指示的操作。
命令行是一个ASCII码文本序列，由空格分隔。第一个字是内嵌命令的名字或者可执行文件的路径，剩余的字是命令行参数。如果第一个字是内嵌命令的名字，shell立即在当前进程执行命令。否则，这个字会被认为是一个可执行程序的路径，shell会产生一个子进程，然后在子进程中加载并运行这个程序。为了解释单个命令行而创建的所有子进程被称为一个作业。一个作业可以包含多个子进程，它们用Unix pipes连接。\
如果命令行以“&”结尾，作业会在后台运行。这意味着shell不会等待作业终止，就打印提示符，等待下一个命令行。否则，作业在前台运行，shell会等待作业终止。任何时刻最多只有一个作业运行在前台。后台可以运行任意数量的作业。\
Unix shell支持作业控制的思想，允许用户在前后台之间移动作业，改变一个作业中的进程状态。输入ctrl-c导致SIGINT信号被传送给前台作业的每个进程，默认行为是终止进程。输入ctrl-z导致SIGTSTP信号被传送给前台的每个进程，默认行为是把进程变为阻塞态，进程可以被SIGCONT信号唤醒。Unix shell提供多种内置命令来支持作业控制。
### 实验任务
tsh.c中是一个Unix shell的骨架，一些函数已经被实现。我们的任务是完成被列出的其余函数。\
eval 解析和解释命令行的主例程 70行\OK
builtin_cmd 识别解释内置命令：quit fg bg jobs 25行\OK
do_bgfg 实现bg和fg内置命令 50行\OK
waitfg 等待一个前台作业完成 20行\OK
sigchld_handler 捕获SIGCHLD信号 80行\
sigint_handler 捕获SIGINT信号（即ctrl-c） 15行\OK
sigtstp_handler 捕获SIGTSTP信号（即ctrl-z） 15行\OK
应该实现的内置命令作用：
quit：终止shell；\
jobs:列出所有后台作业；\
bg <job>：发送SIGCONT信号，把阻塞的后台作业变成运行态，<job>可以是PID或JID；\
fg <job>：发送SIGCONT信号，把阻塞或运行态的后台作业变成运行态的前台作业；\
我们的tsh shell应该有如下特征：\
提示符应当是字符串“tsh>”;\
由用户输入的命令行应当包括一个名称和零个或多个参数，所有字都用一个或多个空格分隔；如果名称是内嵌命令，tsh应当立即处理，然后等待下一个命令行；否则，tsh应当假定名称是一个可执行文件的路径，tsh在一个初始的子进程中加载并执行它；\
tsh不需要支持| < >这三个符号；\
输入ctrl-c/z会导致SIGINT/SIGTSTP信号被发送给前台作业的所有进程，当没有前台作业时，这两个信号没有作用；\
如果命令行以“&”结尾，tsh在后台运行这个作业；否则，它在前台运行；\
每一个作业都由PID或JID指示，它是一个由tsh分配的正整数。JID由%为前缀。比如，“%5”指JID 5,“5”指PID 5；\
tsh应当回收所有的僵死子进程；如果任何作业因为收到了一个它没有捕获的信号而终止，那么tsh应当识别出这个事件，打印一个消息，描述作业的PID和这个违法信号的描述。\
官方提示：\
本实验主要与课本第八章有关；\
waitpid, kill, fork, execve, setpgid, sigprocmask，这些函数会很有用；waitpid的 WUNTRACED和WNOHANG选项会有用；\
当实现了信号相关的函数的时候，确保SIGINT和SIGTSTP信号是发送给整个前台进程集合的；对于kill函数，使用“-pid”而不是“pid”在参数中；\
本实验一个棘手的地方是，确定在waitfg和sigchld_handler函数之间的分配工作；推荐用以下方法：在waitfg,在sleep函数外用一个忙循环；在sigchld_handler，调用一次waitpid。其他解法是可能的；
在eval中，父进程必须用sigprocmask来在它产生子进程之前阻塞SIGCHLD信号，\然后必须在它调用addjob函数把子进程加入作业之后使用sigprocmask函数解除阻塞这个信号，子进程必须在它执行新程序之前确保解除阻塞了SIGCHLD信号；这一条和避免竞争条件有关；\
more, less, vi, 和emacs对终端设置做了一些奇怪的事情，不要在自己的shell里运行这些程序；\
当从标准Unix shell中运行自己的shell时，自己的shell会在前台运行，如果这个shell创建了子进程，这个子进程是在前台的，所以输入ctrl-c也会给shell发送SIGINT信号，然后因为所有进程都是shell的子进程，就也会给shell的所有进程发送这个信号，这是不对的；处理方法是，在fork之后，在execve之前，子进程应当调用setpgid(0,0)，这把子进程放到了一个新的进程组中，组ID是和子进程的PID相同的；这保证了只有shell在前台进程组中；当输入ctrl-c时，shell捕获到这个信号，然后把它发送给合适的前台作业。\
希望实验者编写良好的注释，并检查每个系统调用的返回值。
### 实验过程
根据课本知识和实验提示进行编写即可，主要分析见代码注释。
