# Cache Lab
### 收获
更深入地了解了C程序传递命令行参数的机制，学习熟悉了命令行参数解析函数getopt的使用；\
更加深刻地理解了高速缓存的基本结构，并且成功模拟；\
熟悉并实际运用了“分块”这一在处理矩阵相关运算中强大的优化缓存命中率的技术；

### 总结
本实验旨在帮助我们理解cache memory（高速缓存）对C程序的性能的影响。\
实验有两部分，第一部分我们需要编写一个在200行至300行之间的C程序，模拟一个高速缓存的行为；第二部分我们需要优化一个小型的矩阵转置函数，目标是最小化cache的不命中数。要修改的实验文件是csim.c和trans.c。
### Part A
这一部分，我们需要编写一个缓存模拟器，以一个固定的存储访问流为输入，模拟缓存的命中/不命中行为，并且输出命中、不命中、驱逐总数。\
具体任务是，填充csim.c文件，使它能产生和参考模拟器相同的行为。基本需要从零开始写。如果有块要替换，使用LRU替换策略。\
编程规则：
编译时必须没有警告；\
模拟器必须对于任意s, E, b正确运行，也就是说，需要为模拟器的数据结构用malloc分配内存；另外，这也就是说，s, E, b是输入的参数，回忆一下，s是地址的中间s位，用于索引组，即共有2^s个组；E是每组有E行；b是地址的低b位，表示一个块具有2^b个字节；\
我们只对数据缓存的性能感兴趣，所以模拟器应该忽略所有指令缓存访问；
必须调用函数printSummary，参数是hit, miss, eviction的总数；
对于本实验，应该假设存储访问被合适地对齐了，所以单个的存储访问不会穿过块的边界；通过进行此假设，可以忽略valgrind流的请求大小。\
按照正常思路，从处理输入开始写。
输入是valgrind生成，取指令的内存访问命令前面没有空格，这也是我们需要忽略的；其他命令前面都有空格，然后是字母M或L或S,然后是十六进制地址，然后是表示访问的内存大小。因为前面说单个访问不会越过块的边界，所以其实可以忽略请求了多大的内存，因为整个数据一定和首地址在同一个块里，所以只需要考虑首地址在哪个块。\
整个输入的格式是\
 ./csim-ref [-hv] -s \<s\> -E \<E> -b \<b> -t \<tracefile>\
tracefile是要读取的文件。
实验文档建议用getopt函数处理，学习了一下getopt函数的用法。\
写完处理输入的部分后，就要考虑缓存的模拟了。那需要先实现缓存的结构。缓存由内向外是行-组-缓存这么一个结构。写完结构以后写初始化缓存的函数。
然后就写LSM三种操作的函数。\
然后写处理文件输入的函数。\
结果发现没有想象中难，最难的部分就是学习处理命令行参数和处理文件输入。然后只要结构实现正确，并且正确使用malloc函数即可。真正模拟的部分其实很简单，写起来也很自然。我还发现实验只需要最后给出的三个cnt值正确就能拿满分。
### Part B
Part B的任务是，在trans.c里写一个转置矩阵的函数transpose_submit，使得cache miss数尽可能少。\
编程规则：\
代码编译时必须没有警告；
在一个转置函数中最多定义12个int类型的局部变量；
不允许通过使用任何long类型来回避上一条限制；也不准使用任何技巧来在同一个变量中储存多个值；
不准使用递归；
如果编写了助手函数，不准在栈中一次有超过12个局部变量，意思就是，如果转置函数声明了8个变量，那助手函数最多用4个变量；
不准修改待转置的数组A；
不准定义任何数组，也不准用malloc函数。\
用三种大小的矩阵来给程序评分：32\*32，64\*64，61\*67。
性能评价的方式是，valgrind会生成函数的地址访问流，会通过使用参考缓存模拟器来检测这个流的不命中数。缓存参数是，s=5,E=1,b=5。即，bit[4:0]是块偏移，bit[9:5]是组索引位。剩余的是标记位。
在上述三种规格的矩阵中，不命中数的满分标准分别是300，1300，2000。\
代码只需要能够对这三种规格正确执行。可以为每种规格编写专门的转置函数。\
官方提示：因为E=1，所以冲突不命中会很严重，尤其是在矩阵的对角线上。考虑考虑减少冲突不命中数量的访问方式；\
建议使用分块技术。\
分块技术，查了一下就是把矩阵分成不同大小的子块。
缓存共有32个组，每个组只有一行，每行的块的大小是32字节。矩阵元素是4字节，所以一行可以存8个连续的矩阵元素。整个缓存可以存8\*32=256个矩阵元素。
利用实验提供的调试工具看了一下，数组A首地址10c080，数组B首地址14c080。所以这两个数组首地址的组索引是一样的。所以示例函数会产生很多冲突。
#### 32*32
先写估计应该最简单的32\*32矩阵的情况。
实验提供的示例转置函数，经过测试，在32\*32下不命中数是1183，距离满分差距非常大。\
很明显的事情是，按照示例程序，B完全按列来访问，这样，比如说，B访问B[2][0]，那这一行被加载进了缓存里，但是这个缓存块完全没被重新访问就被驱逐了，这是不合适的。我们肯定希望每一个被加载进的缓存块中的每一个字节都能被访问（矩阵转置运算也不可能重复访问一个元素），这样利用率最高。\
结合官方建议的分块技术，容易想到改进的方法。\
因为整个缓存可以放下矩阵的8行，所以可以把矩阵分为8\*8的子矩阵，对子矩阵进行转置。对于更大的子矩阵，B是会冲突的。\
所以分成8\*8的子矩阵后，不经过对角线的子矩阵A和B一定不会冲突。\
对角线上的转置一定会冲突，所以需要考虑优化办法。那直接用8个局部变量存下子矩阵A的一行，然后赋给子矩阵B的一列就可以了。\
矩阵转置的不命中数可以计算出是32\*32/8\*2+7/8\*32=284<300，实际运行显示不命中287次，可以得满分。
#### 64*64
对于这个规格，整个缓存只能放下矩阵的4行。
如果还是分成大小为8\*8的子矩阵，那其实是不行的，因为对于B，前4行和后4行会产生冲突。只能分成4\*4的子矩阵。但是这种分法是拿不到满分的。\
研究这种分法的缺陷，因为加载一个块是一次加载连续的8个元素，而这种子矩阵只需要一行上的4个元素，所以有4个被加载的元素没有被再次访问。有什么办法能利用另外的4个元素吗？\
这个是真的难。解决办法当然有。就是多重划分。\
我们仍然考虑8\*8的子矩阵，但是对于B来说，在列上一次只能处理4行，不然会冲突。所以对于B要把这个子矩阵划分成两个4\*8的子矩阵，这个4\*8的子矩阵再划分成左右两个4\*4的子矩阵。把A的8_8子矩阵也分成上下两个8_4，8_4A是需要被转置到B的左边一个8\*4的位置。左上子矩阵是可以正常被转置的。我们把本来要转置到左下子矩阵的那个块暂时放在B的右上子矩阵。然后处理A下面那个8_4子矩阵，这时我们就可以把暂时存在B右上子矩阵的元素放回左下子矩阵了，然后再把A的右下矩阵转置给B的右下矩阵，再把A的左下矩阵转置给B的右上矩阵。转置这样一个8\*8块，会产生4+4+4+4=16次不命中，总共是16*64*64/8/8=1024次不命中。
对角线上的仍然会冲突，会有一些额外的不命中，仍然试图采取用局部变量先整个存下来的方法。这个不命中数具体计算，等写出代码后会更容易分析一点，但对角线总共也就64个元素，估计不命中数不会很多，应该是能达到满分要求的。\
写出代码，由测试程序测试后，显示为1171次不命中，达到满分要求。

#### 61*67
这种情形就不能整齐地分块了。但是很容易想象，即使不能整齐分块，只要防止数组越界，并且对元素的操作不重不漏，使用分块技术也是可以正确转置的。\
分块技术由于努力多访问已经被加载进缓存的块中的元素，所以一定是比朴素的方法的不命中数更少的。\
这种情形的规格的总元素数小于64\*64，但是满分要求的不命中数却明显要多许多。可以合理推测，对于此规格，不需要太过巧妙的分块方法就能得到满分。\
另外，由于矩阵形状不整齐，所以各行元素会被映射到的缓存的位置也是比较复杂的，不像前两种情形是按行具有周期性的。所以很难具体计算某种分块方法的不命中数。\
所以，对于此规格，没有太好的方法，可以一个个尝试不同的分块大小，来测试不命中数。\
实测可以发现按照17\*17的方式来划分，不命中数是1950，达到了满分要求。因此已经不必再进一步优化。


