# Malloc Lab
### 收获
熟悉了如何编写内存分配器，有3种常见的组织空闲链表的方法，和3种适配空闲块的方法；\
实际编写程序，要兼顾多个性能指标，这在理论上往往难以直接分析，只能通过编写不同实现方法的版本，进行实际测试来比较；\
复杂的指针运算容易出错，可以把它们封装成宏定义；其他常用的复杂运算也可以封装成宏定义；\
编写了很多助手函数，一定要非常清楚这些函数做了什么任务，否则很可能会弄错。比如，我自己因为没有注意insert函数会修改有效载荷的前两个字，在realloc的时候就先insert然后复制块的数据，这是不对的。
### 总结
这个实验需要我们为C程序编写一个动态内存分配器，即实现malloc, free, realloc函数。实现方案要在正确的基础上尽可能高效快速。
### 实验任务
唯一需要修改的是mm.c文件。需要编写如下四个函数：\
int mm_init(void);\在调用下面三个函数之前，应用程序应当调用此init函数来执行必要的初始化，比如分配初始堆区。失败返回-1，成功返回0。\
void *mm_malloc(size_t size);\返回一个指针，指向一个负载至少size字节的被分配的块。整个块需要在堆区内，不应当和其他块重叠。实验测试会把我们的实现与标准C的实现比较，这要求我们分配的区域是8字节对齐的。\
void mm_free(void *ptr);\释放由ptr指向的块区。这个函数只保证在ptr指向由malloc或realloc分配的还未被释放的区域时生效。\
void *mm_realloc(void *ptr, size_t size);\返回一个指针，指向一个至少有size字节的块。如果ptr为空，此函数等价于调用malloc；如果size等于0，此函数等价于调用free；如果ptr非空，它必须是一个指向之前由malloc或realloc函数分配的区域的指针，本次调用会把这个区域的大小修改成size字节，并且返回指向新块的指针。新块的地址可能和旧块一样，也可能不一样，这取决于实现方法、旧块内部碎片的大小、realloc请求的大小。对于新旧size的共同部分，新块的内容必须和旧块一样，而变化的部分是未初始化的。比如，把8字节的旧块变成12字节的新块，那么新块前8字节和旧块一样，其余4字节未初始化。如果把8字节变成4字节，那么新块只保留旧块的前4字节。\
以上的描述和C标准库中的实现是一样的。\
本实验已经提供了这四个函数的最朴素的实现。\
内存分配器涉及大量无类型指针的操作。写一个堆检查器来检查是有用的。堆检查器的工作可能包括：检查是否free list中的块都是free状态，等等。这不是必须完成的。\
实验支持了一些操作内存系统的例程：\
void *mem_sbrk(int incr):给堆再扩展incr字节，返回一个指向新分配区域第一个字节的无类型指针。incr必须是正整数。\
void *mem_heap_lo(void): 返回指针指向堆的第一个字节。\
void *mem_heap_hi(void): 返回指针指向堆的最后一个字节。\
size t mem_heapsize(void): 返回现在堆的字节数。\
size t mem_pagesize(void): 返回系统的页的大小，字节为单位。\
实验会测试内存分配器的正确性、空间利用率、吞吐量。\
编程规则：\
不要修改mm.c的接口；\
不要调用除了上述函数以外的其他内存管理相关的库函数；\
不要定义全局或静态的复杂数据结构，比如数组、结构体等；\
分配器必须始终返回8字节对齐的指针。\
评分的两个性能指标：\
空间利用率：被分配的内存空间比上分配器申请的堆空间的最大比值。后者是定值，即前者取被分配空间最多的时刻。优化此指标需要尽可能减小碎片。\
吞吐量：一秒能完成的操作数量。\
提示：\
将指针运算都封装在宏中。
### 实验过程
首先根据课本，选定分离的空闲链表技术来实现。\
具体分析可见代码注释。\
测试结果是85分。


