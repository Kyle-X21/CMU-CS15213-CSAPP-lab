# Arch lab
### 收获
熟悉了Y86-64汇编语言，了解了如何编写汇编语言程序；\
了解了HCL语言，了解了如何描述硬件设计；\
了解了在处理器设计层面与在汇编程序层面如何对PCE进行优化，并且如果可能，则两者协同考虑可以实现更佳的优化。
### 未解之谜
Part C自己一开始实现的iaddq指令不知道为啥不行。后来参考了别人写的。
### 总结
这个实验需要了解Y86-64的流水线处理器设计和实现，优化处理器设计和基准程序，以最大化性能。\
本实验帮助学生对代码和硬件之间的影响程序性能的交互有更深入的理解。
### 实验要求
分三个部分。
### Part A
任务是写并且模拟三个Y86-64程序。应当遵循x86-64的惯例来使用寄存器、堆栈。
\
第一个程序，对链表元素迭代求和。\
程序应当能设置堆栈结构、调用函数、停止。\函数应该使用Y86-64代码，并且与给出的C版本等价。
写出关键部分的汇编：\
```python
# ls in rdi
sum:
    irmovq $0, %rax
    jmp test
loop:
    mrmovq (%rdi), %rsi
    addq %rsi, %rax
    mrmovq 0x8(%rdi), %rdi
test:
    andq %rdi, %rdi
    jne loop
    ret
```
测试可知程序编写正确。\
第二个程序，对链表元素递归求和。\
```python
# ls in rdi
rsum:
    pushq %rsi
    irmovq $0, %rax
    andq %rdi, %rdi
    jne label
    popq %rsi
    ret
label:
    mrmovq (%rdi), %rsi
    mrmovq 0x8(%rdi), %rdi 
    call rsum
    addq %rsi, %rax
    popq %rsi
    ret
```
测试可知程序编写正确。\
第三个程序，复制一个内存块，并且返回校验和。\
```python
#src in rdi, dest in rsi, len in rdx
copy:
    irmovq $0, %rax
    irmovq $0x8, %r9
    irmovq $0x1, %r8
    jmp test
loop:
    mrmovq (%rdi), %rcx
    addq %r9, %rdi
    rmmovq %rcx, (%rsi)
    addq %r9, %rsi
    xorq %rcx, %rax
    subq %r8, %rdx
test:
    andq %rdx, %rdx
    jg loop
    ret
```
测试可知程序编写正确。\
Part A完成。
### Part B
任务是扩展SEQ处理器来支持iaddq指令。为了加入这个指令，需要修改文件seq-full.hcl，它实现了SEQ版本。
比较简单，没什么好写笔记的。
### Part C
ncopy函数把一个整数数组scr复制到了dst，返回其中含有的正整数的个数。pipe-full.hcl包含了流水线处理器的实现代码。有IIADDQ指令。\
我们的任务是，修改ncopy.ys和pipe-full.hcl，来让程序ncopy.ys运行得尽可能快。
可以在以下限制内进行任何修改：
ncopy.ys必须能正确运行于任何数组大小；ncopy.ys最多1000字节长；修改后的pipe-full必须能通过测试。\
官方提示：课本5.8关于循环展开的部分可能会有用。\
主要优化思路：\
1，使用iaddq指令进行寄存器和常数的加减法；\
2，循环展开（原理是，循环展开减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支；也提供了方法能进一步减少代码中的操作数量），经测试6*1展开效果较好。此时已经可以得到30%的分数。对不满六路展开的数据，可以进一步进行三路展开；其实四路展开到八路展开之间，性能差距并不明显，PCE的变化在0.1以内；\
3，避免汇编代码中的取数使用型冒险，可以提前进行内存读，使用多个寄存器进行连续读，以避免这种冒险对程序效率的影响；此时可以得到接近80%的分数；\
4，此外对于汇编代码就基本很难再优化了，只能在细节上琢磨，比如，由于iaddq指令和其他opq指令都可以修改条件码，所以在一些地方可以省去专门的条件测试指令；%rax在这里默认初始值是0，所以可以省去一开始的对%rax异或的指令；\
5，上网查阅了一下其他人的优化思路，发现对于汇编代码，还可以采用一些诡异的数据结构，从而在细节上进一步优化；比如用三叉树构建跳转路径，减少指令数。\
6，若还想进一步优化，则需要修改hcl，可以修改分支预测策略为，往低地址跳转则预测跳转，往高地址跳转则预测不跳转，注意编写汇编代码也要和这个策略最大程度地适应；\
7，合理猜想，可以对hcl的处理器设计进行更强的优化，比如增加流水线级数，或是与具体的汇编代码结合，进行一些只针对本题代码的优化，但这太复杂了，而且很容易出错，所以没有去实践。\
最终如果不考虑5和7的优化，得分可以达到90%，看有网友采用5的优化后就拿到了满分。
